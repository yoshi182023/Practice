Before submitting this file, make sure that there are no more TODO
placeholders remaining in the file (and remove this comment too).

Warmup
------

Q1. The display of the Queue in the debugger uses the labels `front` and `back` to mark the two ends of the queue. How are the contents labeled when the Queue contains only one element?
A1. When the Queue contains only one element, the debugger shows it as front/back e.g., front/back 5.
This means the single element acts as both the front (head) and back (tail) of the queue simultaneously.

Q2. For which type of inputs does the function go into an infinite loop?
A2.
The bug arises because the loop both modifies the queue’s size and uses it as a termination condition.
This antipattern causes infinite loops when the size grows faster than the index i.
The function goes into an infinite loop only when the input queue contains only negative numbers and no positive numbers.

Q3. Show your edited code for `duplicateNegatives` that fixes the problem with the infinite loop.
A3. To fix the infinite loop in the original duplicateNegatives function, we need to ensure that we only iterate through the original number of elements, not the changing size of the queue, since new elements (duplicates) are added during the loop.
void duplicateNegatives(Queue<int>& q) {
    int size = q.size();
    for (int i = 0; i < size; i++) {
        int val = q.dequeue();
        q.enqueue(val);
        if (val < 0) {
            q.enqueue(val);   // double up on negative numbers
        }
    }
}
Q4. What is the better fix to `sumStack` that corrects the bug?
A4. int sumStack(Stack<int> s) {

int sum = 0;
while (!s.isEmpty()) {
    sum += s.pop();
}
return sum;
}

 it checks s.isEmpty() before popping, it never tries to pop from an empty stack, preventing the error.

Maze
----
Q5. After you have written your test cases, describe your testing strategy to confirm that your `validatePath` operates as intended. How confident are you that it works correctly in all cases?
A5. I’m fairly confident that validatePath works correctly in all typical and edge cases.
My testing strategy includes both positive and negative cases:
Valid complete path from top-left (entry) to bottom-right (exit) that only uses valid moves and does not repeat any locations.
This ensures the function accepts correct solutions.
Negative cases tested empty path and confirms that the function detects and rejects paths with no steps and
path contains illegal moves and also path contains a loop.


Q6. Most students are sold on the benefit of the fancy features provided by `Vector`, `Grid`, and `Set` but the ADT skeptics may question the value of `Stack` and `Queue` ADTs, seeing them as nothing more than a restricted `Vector`. Make your best argument to convince them of the benefits these ADTS have over `Vector`.
A6. Specialized ADTs like Stack and Queue enforce clear semantics and invariants that prevent misuse, while Vector's flexibility often leads to hidden bugs and ambiguous intent. Their restricted interfaces actually make code more readable, maintainable.


Search Engine
-------------
Q7. List the contents of the inverted index built from the `res/tiny.txt` database file.
A7.
{
    "milk":   {"www.shoppinglist.com"},
    "fish":  {
        "www.shoppinglist.com",
        "www.dr.seuss.net",
        "www.bigbadwolf.com"
    },
    "bread": {"www.shoppinglist.com"},
    "5lb_mms": {"www.shoppinglist.com"},
    "red":   {
        "www.rainbow.org",
        "www.dr.seuss.net"
    },
    "green": {"www.rainbow.org"},
    "blue":  {
        "www.rainbow.org",
        "www.dr.seuss.net"
    },
    "one":   {"www.dr.seuss.net"},
    "two":   {"www.dr.seuss.net"},
    "10":    {"www.dr.seuss.net"},
    "eat":   {"www.bigbadwolf.com"}
}

Beyond Algorithmic Analysis
---------------------------
Q8. In a short paragraph, describe a real or plausible scenario in which reworking an algorithm to improve its efficiency might benefit Earth's environment or humanity as a whole.
Include your thoughts on how a software engineer working on this piece of code might identify such potential benefits and take them into consideration when designing the code.
A8.
Optimizing traffic light algorithms with real-time adaptive control can cut vehicle idling emissions.
Engineers should prioritize efficiency gains that benefit both performance and sustainability.

Q9. According to the contract that IBM struck with the state of Indiana,
the criteria for optimization were improving efficiency of the overall welfare system and
reducing fraud. Criteria for reducing wait times and wrongful denials were not included.
However, wrongfully denying benefits has a huge negative impact on the citizens who rely on the system.
If criteria like minimizing wrongful denials were not included in the contract,
should engineers have included them in their optimization algorithm?  Why or why not?
A9.Engineers should have proactively incorporated criteria to minimize wrongful denials,
even if not explicitly required by the contract.
While the contract focused on cost and fraud reduction,
the system’s ultimate purpose was to serve vulnerable citizens—a goal undermined by algorithm.
Ethical engineering demands prioritizing human welfare over narrow technical specifications.

Q10. Imagine that after completing CS106B you are hired at IBM as an engineer working on this system.
How might you have approached designing and setting the goals of this system?
How might you apply algorithmic analysis tools to build a system that achieved the desired goals?
Could you do so in a way that avoids the severe negative impacts on users of the system that are outlined in the case study?
A10. Corrective mechanisms when errors occur,treating efficiency and equity as complementary goals rather than tradeoffs.
